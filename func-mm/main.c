#include "monty.h"

#include<ctype.h>
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>

#define NDEBUG

typedef struct _rsak_s {
    uint32_t mod[L];
    uint32_t exp[L];
    uint32_t esize;
} rsa_key;

void os2ip(const char *in, uint32_t out[L]){
    memcpy(out, in, L8);
}

void i2osp(const uint32_t in[L], char *out){
    memcpy(out, in, L8);
}

void rsa_edp(const char *in, char *out, const Mont mm, const rsa_key k){
    uint32_t in_rep[L] = {0};
    uint32_t out_rep[L] = {0};
    uint32_t monty[LL] = {0};

    os2ip(in, in_rep);
    mm_conv(in_rep, &mm, monty);

    mm_exp(monty, k.exp, k.esize, &mm);

    mm_redc(monty, &mm, out_rep);
    i2osp(out_rep, out);
}

void rsa_proc(FILE *in, FILE *out, int prn, const rsa_key k){
    char inchunk[L8] = {0};
    char outchunk[L8] = {0};
    Mont mm;

    mm_init(k.mod, &mm);

    while((fread(inchunk, sizeof(char), L8, in)) != 0){
        rsa_edp(inchunk, outchunk, mm, k);
        if(out) fwrite(outchunk, sizeof(char), L8, out);
        if(prn) printf("%.*s", L8, outchunk);

        memset(outchunk, 0, L8);
        memset(inchunk, 0, L8);
    }
}

rsa_key getkey(FILE *keyfile){
    char a[3] = {0};
    char buf[L8] = {0};
    rsa_key k = {{0}, {0}};

    // get the modulus

    fscanf(keyfile, "%c%c", a, a+1);
    if(a[0] != '0' || a[1] != '0'){
        printf("fatal: modulus does not start with 00. but %s\n", a);
        exit(1);
    }

    int i = L8 - 1;
    while(fscanf(keyfile, "%c%c", a, a+1) && (i >= 0)){
        if(a[0] == '!' || a[1] == '!') break;
        buf[i] = (char)(strtoul(a, NULL, 16));
        i--;
    }
    os2ip(buf, k.mod);

    // get the private exponent

    memset(buf, 0, L8);
    i = L8 - 1;
    fscanf(keyfile, "%c%c", a, a+1);
    if(a[0] != '0' || a[1] != '0'){
        buf[L8-1] = (char)strtoul(a, NULL, 16);
        i--;
    }
    while(fscanf(keyfile, "%c%c", a, a+1) && (i >= 0)){
        buf[i] = (char)strtoul(a, NULL, 16);
        i--;
    }
    os2ip(buf, k.exp);

    // finally, find out how large the exponent is

    if (k.exp[L-1] == 0){
        printf("fatal: private exponent too small for fixed public exponent (F4)\n");
        exit(1);
    }
    for(i=wb-1; i >= 0; i--){
        if((k.exp[L-1] >> i) & 1) break;
    }
    k.esize = ((L-1)*wb) + i;

    return k;
}

int main(int argc, char *argv[]){
    int print_result = 0;
    int dir = 0;
    char *keyfile = 0;
    char *infile = 0;
    char *outfile = 0;

    char *usage =
"[-dp] -k <keyfile> -i <input file> [-o <output file>]\n"
"    options:\n"
"    -d  decrypt using the OpenSSL standard public exponent F4 (65537). otherwise, [default] encrypt using the private \n"
"        exponent in <keyfile>.\n"
"    -p  [optional] print the result of the encryption/decryption to stdout.\n"
"    -k  the (easy-format) keyfile. this can be generated by extracting the modulus and private exponent from a PEM\n"
"        file with `openssl -in <pemfile> -noout -text` and some awk parsing.\n"
"    -i  the input file.\n"
"    -o  [optional] the output file.\n";

    int c = 0;
    while((c = getopt(argc, argv, "k:i:o:pd")) != -1){
        switch(c){
            case 'k':
                keyfile = optarg;
                break;
            case 'i':
                infile = optarg;
                break;
            case 'o':
                outfile = optarg;
                break;
            case 'p':
                print_result = 1;
                break;
            case 'd':
                dir = 1;
                break;
            case '?':
                printf("usage: %s %s", argv[0], usage);
            default:
                return 1;
        }
    }
    if(!keyfile){
        printf("fatal: no keyfile specified\nusage: %s %s", argv[0], usage);
        return 1;
    }
    if(!infile){
        printf("fatal: no textfile specified\nusage: %s %s", argv[0], usage);
        return 1;
    }

    FILE * fk = fopen(keyfile, "r");
    FILE * fi = fopen(infile, "r");
    FILE * fo = NULL;
    if(outfile){
        fo = fopen(outfile, "w");
    }

    rsa_key kd = getkey(fk);
    rsa_key ke = {{0}, {0}, 0};
    mv(kd.mod, ke.mod);
    ke.exp[0] = 0x10001;
    ke.esize = 16;

    if(dir)
        rsa_proc(fi, fo, print_result, ke);
    else
        rsa_proc(fi, fo, print_result, kd);

    return 0;
}

